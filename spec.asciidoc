= AIML 2.0
:toc:

image::img/aiml-2.0.png[]

== Introduction

This document is a draft specification for a new AIML (Artificial Intelligence
Markup Language) standard, version 2.0 of the language. AIML is an XML
language for specifying the contents of a chat robot character. An AIML
Interpreter is a program capable of loading and running the bot, and providing
the bot’s responses in a chat session with a human user, called the client.
This document explains in detail both the syntax and semantics of AIML, as
well as key features that should be supported by an AIML interpreter.

The primary design goal of the original AIML language was simplicity. AIML
is motivated by two observations:

. Creating an original, believable chatbot character requires writing a
significant amount of content, in the form of conversational
replies.footnote:[This proposition may not be true for chatbots based on other
technologies. AIML implements a form of supervised learning, where a person,
the botmaster, plays a crucial role in training the bot. Unsupervised learning
systems, on the other hand, attempt to teach a bot through conversations, in
effect crowdsourcing the bot content. The unsupervised model has its own
drawbacks however. Specifically, the bot database becomes filled with
nonsense, which then an editor must later delete. The tradeoff between
supervised and unsupervised methods might be summarized as “Creative writing
vs. deleting garbage.”]
. The people who are most suited to writing the bot content are not, by in
large, computer programmers. Those with literary backgrounds are more skilled
at developing content for original characters.footnote:[The caveat to this
observation is that there are of course, some talented people who have
mastered both computer programming and the literary skill to write quality
chatbot content.]

When AIML was first designed in the late 1990’s, the World Wide Web had burst
upon the stage and a rush of creative energy was poured into building
websites. This tsunami of activity has in fact continued to this day. What has
changed however is that the web lost its original simplicity. Perhaps it was
inevitable as users demanded more and more sophisticated services through the
web, that layers of complexity would be added. In 1994 however it was possible
to author a web site with only rudimentary knowledge of a few HTML tags.

Because at that time, a number of creative people had mastered the then-simple
HTML, I made a decision to create an equally simple AIML. I was fond of
saying, “anyone who knows enough HTML to make a website, can learn enough AIML
to write a chatbot."

A parallel development beginning in the 1990’s was the development of XML,
including specifications, standards, documents, tools, and applications for
XML. Perhaps the world has not gone the way that the XML evangelists hoped in
the 1990’s, as its many competing formats remain viable today. But XML has not
gone away either. It remains true that XML is a broadly supported standard,
and its tag-based representation is easy to grasp without sophisticated
knowledge of computer science. AIML authors have found the many XML tools,
such as DTDs, syntax checkers, and editors, to be useful when creating bots.

For these reasons AIML 2.0 remains hitched to the XML wagon.

At some level however, AIML does not depend on XML syntax. There is a deeper
representation of the data we represent in XML files. As long as the
representation can capture the basic structure of a pattern path (the input
pattern, that pattern and topic pattern), and a hierarchical response
template, then AIML could be written in a number of different formats,
including Lisp S-expressions, JSON, or a structured text format. The AIML 2.0
draft even includes an alternative representation: a hybrid of flat files and
XML called AIML Intermediate Format (described in a section below).

Modifying AIML inevitably reduces some of its original simplicity. Adding more
tags and more features make the language more difficult for people to
understand. The urge to keep it as simple as possible is tempered by our
experience over the past decade, in which AIML botmasters learned that the
language had some serious limitations. AIML 2.0 is an attempt to address the
shortcomings, while balancing the original goal of keeping the language as
simple as possible. This AIML 2.0 draft specification is, for the most part,
designed to be backwards-compatible with the AIML 1.0 and earlier standards,
in that way preserving the simplicity of the original language. What’s new are
some new features that build on top of the original language in such a way
that the concepts can be pedagogically organized so that AIML can be taught in
beginner, intermediate and advanced levels.

=== What's new in AIML 2.0?

* *Zero+ wildcards*: new wildcards that match 0 or more words.
* *Highest priority matching*: select certain words to have top matching priority
* *Migrating from attributes to tags*: more dynamic control of attribute values
* *AIML Sets*: match inputs with sets of words and phrases
* *AIML Maps*: map set elements to members of other sets
* *Loops*: Iterations
* *Local variables*: variables with scope limited to one category.
* *Sraix*: access external web services and other Pandorabots
* *Denormalization*: the (approximate) inverse of normalization.
* *Pandorabots extensions*
** *date*: formatted date and time
** *request*: access previous input request history.
** *response*: access previous bot response history
** *unbound predicates*: check if a predicate has been set or not
** *learn*: learn new AIML categories
** *learnf*: learn new AIML categories and save in a file
** *explode*: split words and phrases into individual character
* *OOB (Out of Band) Tags*: AIML extension for mobile device control

=== What's gone from AIML 1.0?

- *Gossip*: never well defined anyway
- *Javascript*: The interpreter does not have to support a scripting language (to be restored in AIML 2.1).

== AIML System overview

AIML defines a relationship between three entities: a human chatter called the
client, a human chat bot author called the botmaster, and the robot or bot
itself. In general a botmaster can author multiple bots, and each bot can have
multiple clients. A system like Pandorabots provides for multiple botmasters,
multiple bots, and multiple clients. An AIML system embedded in a consumer
device might have only one bot and one client. The AIML standard does not
specify the number of bots, botmasters or clients (except that defining AIML
means we have to talk about at least one of each). The details of handling
multiple bots, botmasters and clients is left up to the implementation.

Care should be taken however to manage the state of each bot and each client
session.

=== Bot configuration and state

AIML Files:: Each bot is assumed to have its own set of AIML files. This
collection of AIML files uniquely defines the personality of the bot
character. A bot may be a clone of another bot, or may connect to another bot
through <sraix> (defined below) but for the purpose of defining the AIML
language, the simple assumption is that each bot has its own AIML files.

Learnf file:: one AIML file with special meaning is the file created by the
<learnf> tag (defined below). When an AIML template activates a <learnf> tag,
the bot remembers or “learns" the new category, specially, by saving it in a
file given a specific name by the interpreter (for example, learnf.aiml). The
new categories learned with <learnf> are global to all clients chatting with
the bot, so the learnf file should be part of the bot’s AIML file collection.

Bot properties:: global values for a bot, such as <bot name="name"/> or <bot
name=”species"/>. A multiple bot system should take care to maintain bot
properties individually and separately for each bot.

Substitutions:: normalizing substitutions, person substitutions, gender
substitutions and sentence splitters are unique to each bot. Many bots may use
copies of the same substitutions, but a multiple-bot system should ensure that
each bot can have its own custom substitutions.

Predicate defaults:: Predicate values in AIML are like local variables
specific to one client. Typically one thinks of client profile information
like name, age and gender predicates, but predicates can be used to store any
string. AIML predicates are set with the <set name="predicate"> tag and
retrieved with the <get name="predicate"/> tag. Predicates are specific to an
individual client, but the predicates may have default values that are defined
for a specific bot. There should also be a global predicate default for any
predicate whose default value is not specified for a bot.

Sets and Maps:: AIML 2.0 includes a feature that implements sets (collections)
and maps. The sets members are strings and the maps define a mapping from
string to string. Unique collections of Sets and Maps may be defined for each
bot.

The AIML standard does not specify where or how the properties, sets, maps,
substitutions and predicates are defined. This is an implementation detail
left up to the interpreter designer. The values could be entered through a
user interface, saved in text files or a database, or in any other format
including XML and JSON, as long as the interpreter can read them when the bot
is launched.
