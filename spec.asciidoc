= AIML 2.0
:toc:

image::img/aiml-2.0.png[]

== Introduction

This document is a draft specification for a new AIML (Artificial Intelligence
Markup Language) standard, version 2.0 of the language. AIML is an XML
language for specifying the contents of a chat robot character. An AIML
Interpreter is a program capable of loading and running the bot, and providing
the bot’s responses in a chat session with a human user, called the client.
This document explains in detail both the syntax and semantics of AIML, as
well as key features that should be supported by an AIML interpreter.

The primary design goal of the original AIML language was simplicity. AIML
is motivated by two observations:

. Creating an original, believable chatbot character requires writing a
significant amount of content, in the form of conversational
replies.footnote:[This proposition may not be true for chatbots based on other
technologies. AIML implements a form of supervised learning, where a person,
the botmaster, plays a crucial role in training the bot. Unsupervised learning
systems, on the other hand, attempt to teach a bot through conversations, in
effect crowdsourcing the bot content. The unsupervised model has its own
drawbacks however. Specifically, the bot database becomes filled with
nonsense, which then an editor must later delete. The tradeoff between
supervised and unsupervised methods might be summarized as “Creative writing
vs. deleting garbage.”]
. The people who are most suited to writing the bot content are not, by in
large, computer programmers. Those with literary backgrounds are more skilled
at developing content for original characters.footnote:[The caveat to this
observation is that there are of course, some talented people who have
mastered both computer programming and the literary skill to write quality
chatbot content.]

When AIML was first designed in the late 1990’s, the World Wide Web had burst
upon the stage and a rush of creative energy was poured into building
websites. This tsunami of activity has in fact continued to this day. What has
changed however is that the web lost its original simplicity. Perhaps it was
inevitable as users demanded more and more sophisticated services through the
web, that layers of complexity would be added. In 1994 however it was possible
to author a web site with only rudimentary knowledge of a few HTML tags.

Because at that time, a number of creative people had mastered the then-simple
HTML, I made a decision to create an equally simple AIML. I was fond of
saying, “anyone who knows enough HTML to make a website, can learn enough AIML
to write a chatbot.”

A parallel development beginning in the 1990’s was the development of XML,
including specifications, standards, documents, tools, and applications for
XML. Perhaps the world has not gone the way that the XML evangelists hoped in
the 1990’s, as its many competing formats remain viable today. But XML has not
gone away either. It remains true that XML is a broadly supported standard,
and its tag-based representation is easy to grasp without sophisticated
knowledge of computer science. AIML authors have found the many XML tools,
such as DTDs, syntax checkers, and editors, to be useful when creating bots.

For these reasons AIML 2.0 remains hitched to the XML wagon.

At some level however, AIML does not depend on XML syntax. There is a deeper
representation of the data we represent in XML files. As long as the
representation can capture the basic structure of a pattern path (the input
pattern, that pattern and topic pattern), and a hierarchical response
template, then AIML could be written in a number of different formats,
including Lisp S-expressions, JSON, or a structured text format. The AIML 2.0
draft even includes an alternative representation: a hybrid of flat files and
XML called AIML Intermediate Format (described in a section below).

Modifying AIML inevitably reduces some of its original simplicity. Adding more
tags and more features make the language more difficult for people to
understand. The urge to keep it as simple as possible is tempered by our
experience over the past decade, in which AIML botmasters learned that the
language had some serious limitations. AIML 2.0 is an attempt to address the
shortcomings, while balancing the original goal of keeping the language as
simple as possible. This AIML 2.0 draft specification is, for the most part,
designed to be backwards-compatible with the AIML 1.0 and earlier standards,
in that way preserving the simplicity of the original language. What’s new are
some new features that build on top of the original language in such a way
that the concepts can be pedagogically organized so that AIML can be taught in
beginner, intermediate and advanced levels.

=== What's new in AIML 2.0?

* *Zero+ wildcards*: new wildcards that match 0 or more words.
* *Highest priority matching*: select certain words to have top matching priority
* *Migrating from attributes to tags*: more dynamic control of attribute values
* *AIML Sets*: match inputs with sets of words and phrases
* *AIML Maps*: map set elements to members of other sets
* *Loops*: Iterations
* *Local variables*: variables with scope limited to one category.
* *Sraix*: access external web services and other Pandorabots
* *Denormalization*: the (approximate) inverse of normalization.
* *Pandorabots extensions*
** *date*: formatted date and time
** *request*: access previous input request history.
** *response*: access previous bot response history
** *unbound predicates*: check if a predicate has been set or not
** *learn*: learn new AIML categories
** *learnf*: learn new AIML categories and save in a file
** *explode*: split words and phrases into individual character
* *OOB (Out of Band) Tags*: AIML extension for mobile device control

=== What's gone from AIML 1.0?

- *Gossip*: never well defined anyway
- *Javascript*: The interpreter does not have to support a scripting language (to be restored in AIML 2.1).

== AIML System overview

AIML defines a relationship between three entities: a human chatter called the
client, a human chat bot author called the botmaster, and the robot or bot
itself. In general a botmaster can author multiple bots, and each bot can have
multiple clients. A system like Pandorabots provides for multiple botmasters,
multiple bots, and multiple clients. An AIML system embedded in a consumer
device might have only one bot and one client. The AIML standard does not
specify the number of bots, botmasters or clients (except that defining AIML
means we have to talk about at least one of each). The details of handling
multiple bots, botmasters and clients is left up to the implementation.

Care should be taken however to manage the state of each bot and each client
session.

=== Bot configuration and state

AIML Files:: Each bot is assumed to have its own set of AIML files. This
collection of AIML files uniquely defines the personality of the bot
character. A bot may be a clone of another bot, or may connect to another bot
through `<sraix>` (defined below) but for the purpose of defining the AIML
language, the simple assumption is that each bot has its own AIML files.

Learnf file:: one AIML file with special meaning is the file created by the
`<learnf>` tag (defined below). When an AIML template activates a `<learnf>` tag,
the bot remembers or “learns” the new category, specially, by saving it in a
file given a specific name by the interpreter (for example, learnf.aiml). The
new categories learned with `<learnf>` are global to all clients chatting with
the bot, so the learnf file should be part of the bot’s AIML file collection.

Bot properties:: global values for a bot, such as `<bot name="name"/>` or `<bot
name="species"/>`. A multiple bot system should take care to maintain bot
properties individually and separately for each bot.

Substitutions:: normalizing substitutions, person substitutions, gender
substitutions and sentence splitters are unique to each bot. Many bots may use
copies of the same substitutions, but a multiple-bot system should ensure that
each bot can have its own custom substitutions.

Predicate defaults:: Predicate values in AIML are like local variables
specific to one client. Typically one thinks of client profile information
like name, age and gender predicates, but predicates can be used to store any
string. AIML predicates are set with the `<set name="predicate">` tag and
retrieved with the `<get name="predicate"/>` tag. Predicates are specific to an
individual client, but the predicates may have default values that are defined
for a specific bot. There should also be a global predicate default for any
predicate whose default value is not specified for a bot.

Sets and Maps:: AIML 2.0 includes a feature that implements sets (collections)
and maps. The sets members are strings and the maps define a mapping from
string to string. Unique collections of Sets and Maps may be defined for each
bot.

The AIML standard does not specify where or how the properties, sets, maps,
substitutions and predicates are defined. This is an implementation detail
left up to the interpreter designer. The values could be entered through a
user interface, saved in text files or a database, or in any other format
including XML and JSON, as long as the interpreter can read them when the bot
is launched.

=== Client session and state

Initialization:: when a client connects to a bot, before they begin chatting,
the bot must initialize a client session. The client session is assigned a
unique ID so that the AIML interpreter can track the state of the
conversation. This is important when a single bot is chatting with multiple
clients, for example a web based bot.

Predicate defaults:: Initialization step also includes setting predicates to
the default values specified for the bot.

Predicate state:: The chat session must keep track of the state of predicate
values. Whenever a client activates an AIML category, potentially the <set>
tag is some predicate values may change. The interpreter must remember the
predicate values through the course of the conversation.

Topic:: The AIML topic is a unique predicate value, because it becomes part of
the pattern matching process. The topic can be set with `<set name="topic">`.

Conversation log:: Generally an interpreter keeps a conversation log of the
interactions between a bot and a client. The AIML 2.0 draft does not specify
how or in what format these logs are stored.

History:: The AIML 2.0 draft does however specify that the bot maintain,
within a chat session, a history of interactions for the purpose of evaluating
the tags `<that>`, `<input>`, `<request>` and `<response>`. The size of the
history (the number of elements saved or remembered) is left up to the
interpreter designer.

Learned categories:: Categories learned with <learnf> are saved globally for
the bot (see Learnf file above), but categories learned with the `<learn>` tag
are specific to each client. The chat session should maintain any categories
learned with `<learn>`.

=== Counting interactions and sentence splitting

The basic step of AIML pattern matching is to match one input sentence against
the bot’s set of AIML categories. Because inputs and responses may contain
more than one sentence, AIML has adopted a particular system for counting and
indexing inputs and outputs.

//TODO: unfinished sentence
// When the bot receives a multiple-sentence input

In general one input sentence may result in 1 or more output sentences.

* `<input/>` - the current input sentence
* `<input index="2"/>` - the previous input sentence
* `<input index="N"/>` - the Nth previous input sentence.
* `<request/>` = `<request index="1"/>` - the client’s last input request, consisting of one or more input sentences.
* `<request index="2"/>` - the client’s 2nd to last input request.
* `<request index="N"/>` - the client’s Nth to last input request.
* `<response/>` = `<response index="1"/>` - the bot’s last response, consisting of one or more sentences.
* `<response index="2"/>` - the bot’s second to last response.
* `<response index="N"/>` - the bot’s Nth to last response.
* `<that/>` = `<that index="1,1"/>` - the last sentence the bot uttered.
* `<that index="1,2"/>` - the 2nd to last sentence in `<response index="1"/>`, provided it exists.
* `<that index="2,1"/>` - The last sentence of `<response index="2"/>`.

====
[%hardbreaks]
Human: Hello
Robot: Hi nice to see you!
Human: How are you? My name is Jeff.
Robot: I’m very well. How are you doing? What's up, Jeff?
Human: I’m talking to a robot
Robot: Would you like to say more about that?
Human: Sure
====

At this point, the bot finds a category with a response to the input “Sure”.
The following table summarizes the current state of input/that and
request/response history at the time when that category’s template is
evaluated:

[options="header"]
|===
| Entity | Normalized Sentence | input/that | request/response
| Human | Hello | `<input index="5"/>` | `<request index="3"/>`
| Robot | Hi nice to see you | `<that index="3,1"/>` | `<response index="3"/>`
| Human | How are you | `<input index="4"/>` | `<request index="2"/>`
| | My name is Jeff | `<input index="3"/>` |
| Robot | I am very well | `<that index="2,3"/>` | `<response index="2"/>`
| | How are you doing | `<that index="2,2"/>` |
| | What is up Jeff | `<that index="2,1"/>` |
| Human | I'm talking to a robot | `<input index="2"/>` | `<request/>`
| Robot | Would you like to say more about that | `<that/>` | `<response/>`
| Human | Sure | `<input/>` |
|===

== Migrating from attributes to tags in AIML 2.0

One odd feature of XML is the distinction between tags and attributes.
Consider the HTML img tag in an expression like:

----
<img src="http://alicebot.org/logo.jpg"/>
----

Why was this tag developed to use an attribute, rather than a subtag like:

----
<img><src>http://alicebot.org/logo.jpg</src></img>
----

HTML is interpreted in a static way, but an XML language can be defined to
interpret tags dynamically. For XML languages like AIML, the problem with
attributes is that they are not easy to rewrite dynamically. Suppose we want
the value of the src attribute to vary depending on another XML expression:

----
<img><src><getCompanyLogo/></src></img>
----

The problem in XML is that you can’t put an XML expression inside an
attribute. This is forbidden in XML syntax:

----
<img src="<getCompanyLogo/>"/>
----

Of course, this problem is not hard to solve with a little computer
programming. The XML attribute values can be rewritten by another process
writing the XML. But at least for AIML and XML languages like it, we would
like to specify attribute values dynamically, and allow the botmaster to write
the expressions for those values in XML.

Fortunately the problem has a simple solution: don’t use attributes. Any value
in an attribute can just as well be represent with a subtag as in our example:

----
<img><src>http://alicebot.org/logo.jpg</src></img>
----

AIML 2.0 modifies the definition of every AIML tag that takes an attribute so
that the attribute value can be specified with a subtag having the same name.
For example, these are equivalent:

[options="header"]
|===
| Attribute form | Tag form
| `<get name="age"/>` | `<get><name>age</name></get>`

| `<condition name="job" value="manager">Hi, boss!</condition>`
| `<condition><name>job</name><value>manager</value>Hi, Boss!</condition>`

| `<date format="%D %H"/>`
| `<date><format>%D %H</format></date>`

|===

Even more generally, the contents inside the attribute tags may be any
template expression, as these examples show:

----
<get>
  <name>
    <srai>PREDICATE NAME</srai>
  </name>
</get>

<condition>
  <name>job</name>
  <value>
    <get>
      <name>profession</name>
    </get>
  </value>
  Hi, Boss!
</condition>

<date>
  <format>
    <get name="localdateformat"/>
  </format>
</date>
----

Care should be taken to ensure that whatever these template expressions return
is a valid expression for the attribute. For example in:

----
<star><index><srai>GET INDEX</srai></index></star>
----

The `<srai>GET INDEX</srai>` should return a valid index number > 0.

To retain backwards compatibility, either the attribute form or the subtag
form may be used in AIML 2.0. In the definitions of XML tags that follow, with
a couple of exceptions noted, the attribute values may also be written in the
subtag form.

include::syntax.asciidoc[]

include::pattern-language.asciidoc[]
